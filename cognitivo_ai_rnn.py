# -*- coding: utf-8 -*-
"""Cognitivo-ai RNN.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1r8HgydzXcMaJGNGOAKL_3OvPiHNJ9dN9

## TESTE TÉCNICO DATA SCIENCE
#2) Modelagem - Redes Neurais 
## <span style="color:darkred">Rômulo Róseo Rebouças</span>
"""

import random
import numpy as np
import matplotlib.pyplot as plt
import tensorflow as tf
from numpy.random import seed
from tensorflow.random import set_seed
from tensorflow import keras
from tensorflow.keras import layers
from keras.models import Model, Sequential

import numpy as np
import pandas as pd
import matplotlib

"""# **RNN com base de dados sem tratamento de balanceamento**"""

##-- Leitua Cadastro sem balanceamento
df = pd.read_pickle('bd_SemBalanceamento.pkl') 
df

####
print(df['room_type_tgt'].unique())
print(df.shape)

rotulos = np.array(df['room_type_tgt'])
features = np.array(df.iloc[:, 0:-1])

##-- Separando os dados:

perc_train = 0.7

n_train = int(features.shape[0]*perc_train)
n_test = int(features.shape[0]*(1-perc_train))

x_train =  features[0:n_train,:]
y_train = rotulos[0:n_train]

x_test =  features[0:n_test,:]
y_test = rotulos[0:n_test]

# transformar categorias em one-hot-encoding
y_train = keras.utils.to_categorical(y_train, 4)
y_test = keras.utils.to_categorical(y_test, 4)

print("\nConj. Train: ", len(x_train))
print("Conj. Y Train : ", len(x_train))
print("\nConj. Test ", len(x_test))
print("Conj. Y Test : ", len(y_test))

##-- Rede neural profunda
def model_rnn (input_shape, dropout_rate=0.0):
    
    inputs = keras.Input(shape=input_shape)
    x = layers.BatchNormalization()(inputs)
    x = layers.Dense(32, activation="relu")(x)
    x = layers.Dense(64, activation="relu")(x)
    x = layers.Dropout(dropout_rate)(x)
    x = layers.BatchNormalization()(x)
    x = layers.Dense(64, activation="relu")(x)
    x = layers.Dense(32, activation="relu")(x)
    outputs = layers.Dense(4, activation="softmax")(x)

    return keras.Model(inputs, outputs)

input_shape = 6

model = model_rnn(input_shape , 0.2)
model.summary()

##-- inicializando e treinando  
##-- Taxa de aprendizado inicial de 0.001 e com decaimento em todas as épocas exponencial a -0.3
seed(1)
set_seed(2)

def scheduler(epoch, lr):
    return np.clip(lr * tf.math.exp(-0.3), 0.00001, 0.001)
    
callbacklr = tf.keras.callbacks.LearningRateScheduler(scheduler)

##-- Uso de pesos para as classes: menor peso para classes majoritárias (0 e 2) e maior peso para classes minoritárias (1 e 3)
class_weight = {0: 0.5, 1: 0.7, 2: 0.5, 3: 0.9}

epochs = 20
batch_size = 16

model.compile(loss='categorical_crossentropy', optimizer=keras.optimizers.Adam(lr=0.001),
              metrics=[tf.keras.metrics.Precision(name='precision'), tf.keras.metrics.Recall(name='recall'), 'accuracy'] )
##-- Conjunto
hist_bdnormal = model.fit(x_train, y_train, class_weight=class_weight,
             callbacks=[callbacklr], batch_size=batch_size, epochs=epochs, verbose=1)

hist_bdnormal_t = model.fit(x_train, y_train,
                    batch_size=batch_size,
                    epochs=epochs, 
                    verbose=0)

score1_Tr = model.evaluate(x_train, y_train, verbose = 0)
score1_Te = model.evaluate(x_test, y_test, verbose = 0)

"""# **RNN com Balanceamento SMOTEENN (combinado)**"""

##-- Leitua Cadastro com balanceamento - SMOTEENN (combinado)
df = pd.read_pickle('bd_SMOTEENN_Comb.pkl') 
df

####
print(df['room_type_tgt'].unique())
print(df.shape)

rotulos = np.array(df['room_type_tgt'])
features = np.array(df.iloc[:, 0:-1])

##-- Separando os dados:

perc_train = 0.7

n_train = int(features.shape[0]*perc_train)
n_test = int(features.shape[0]*(1-perc_train))

x_train =  features[0:n_train,:]
y_train = rotulos[0:n_train]

x_test =  features[0:n_test,:]
y_test = rotulos[0:n_test]

# transformar categorias em one-hot-encoding
y_train = keras.utils.to_categorical(y_train, 4)
y_test = keras.utils.to_categorical(y_test, 4)

print("\nConj. Train: ", len(x_train))
print("Conj. Y Train : ", len(x_train))
print("\nConj. Test ", len(x_test))
print("Conj. Y Test : ", len(y_test))

input_shape = 6

model_bdBal = model_rnn(input_shape , 0.2)
model_bdBal.summary()

##-- inicializando e treinando  
##-- Taxa de aprendizado inicial de 0.001 e com decaimento em todas as épocas exponencial a -0.3
seed(1)
set_seed(2)

def scheduler(epoch, lr):
    return np.clip(lr * tf.math.exp(-0.3), 0.00001, 0.001)
    
callbacklr = tf.keras.callbacks.LearningRateScheduler(scheduler)

##-- Uso de pesos para as classes: menor peso para classes majoritárias (0 e 2) e maior peso para classes minoritárias (1 e 3)
class_weight = {0: 0.5, 1: 0.7, 2: 0.5, 3: 0.9}

epochs = 20
batch_size = 16

model_bdBal.compile(loss='categorical_crossentropy', optimizer=keras.optimizers.Adam(lr=0.001),
              metrics=[tf.keras.metrics.Precision(name='precision'), tf.keras.metrics.Recall(name='recall'), 'accuracy'] )
##-- Conjunto
hist_bdBal = model_bdBal.fit(x_train, y_train, class_weight=class_weight,
             callbacks=[callbacklr], batch_size=batch_size, epochs=epochs, verbose=1)

hist_bdBalanc_t = model_bdBal.fit(x_train, y_train,
                    batch_size=batch_size,
                    epochs=epochs, 
                    verbose=0)

score1_TrBal = model_bdBal.evaluate(x_train, y_train, verbose = 0)
score1_TeBal = model_bdBal.evaluate(x_test, y_test, verbose = 0)

"""# **Resulta da RNN considerando a base de dados normal *versus* a RNN com base de dados com o tratamento do Balanceamento SMOTEENN (hibrido)**"""

##-- Gráfico da precisão e revocação no treinamento S e teste T
plt.figure(figsize=(8,5))
plt.plot(hist_bdnormal.history['precision'], 'g')
plt.plot(hist_bdnormal.history['recall'], 'g--')
plt.plot(hist_bdBal.history['precision'], 'r')
plt.plot(hist_bdBal.history['recall'], 'r--')
plt.ylabel('Medidas' )
plt.legend(["Precisão Train.", "Revocação Train.", "Precisão Trein. BD Balanc.", "Revocação Trein. BD Balanc."], loc="best")
plt.title('Treinamento BD Normal x BD com Balanceamento Hibrido')

"""#### >> Houve ganho significativo com o tramento da base com balanceamento Smoteenn (hibrido) com a utilização da rede neural."""

print("Acurácia treinamento - BD Normal: %.4f" % (score1_Tr[1]))
print("Acurácia teste - BD Normal: %.4f" % (score1_Te[1]))

print("Acurácia treinamento - BD Balanc.: %.4f" % (score1_TrBal[1]))
print("Acurácia teste - BD Balanc.: %.4f" % (score1_TeBal[1]))